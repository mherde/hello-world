package de.unikassel.ir.vsr;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TreeSet;

public class PhraseSearchIndex extends InvertedIndexImpl implements PhraseSearch {

	@Override
	public Map<Document, List<Integer>> searchPhrase(List<String> phrase) {

		/* documents containing phrase */
		Map<Document, List<Integer>> result = new HashMap<>();

		/* ensuring phrase not to be null and phrase has at least one element */
		if (phrase == null || phrase.isEmpty())
			return result;

		List<TreeSet<Pair>> lists = this.createSortedSets(phrase);

		if (lists.isEmpty()) {
			return result;
		}

		// for(TreeSet<Pair> list : lists){
		// for(Pair pair : list)
		// System.out.print(list);
		// System.out.println();
		// }

		Iterator<Pair> firstTerm = lists.get(0).iterator();

		while (firstTerm.hasNext()) {

			boolean match = true;

			for (int j = 1; j < lists.size(); j++) {

				Pair dk_j_1 = lists.get(j-1).iterator().next();

				Iterator<Pair> jthTerm = lists.get(j).iterator();

				Pair dk_j = jthTerm.next();

				while (jthTerm.hasNext() && !(dk_j.getDocument().getId().compareTo(dk_j_1.getDocument().getId()) != 1
						|| (dk_j.getDocument().getId().equals(dk_j.getDocument().getId())
								&& dk_j.getPosition() >= (dk_j_1.getPosition() + 1)))) {
					dk_j = jthTerm.next();
				}
				
				if(!dk_j.getDocument().getId().equals(dk_j_1.getDocument().getId()) || dk_j_1.getPosition() != dk_j.getPosition()+1)

			}
		}

		return result;

	}

	private List<TreeSet<Pair>> createSortedSets(List<String> phrase) {

		List<TreeSet<Pair>> lists = new ArrayList<>();

		for (String token : phrase) {

			token = token.toLowerCase();

			if (tokenHash.get(token) == null) {
				lists = new ArrayList<>();
				break;
			}

			TreeSet<Pair> sortedSet = new TreeSet<>();

			for (TokenOccurrence occ : tokenHash.get(token).getTokenOccurrenceList()) {
				for (int position : occ.getPositions()) {
					sortedSet.add(new Pair(occ.getDocument(), position));
				}
			}

			lists.add(sortedSet);
		}

		return lists;

	}

	private class Pair implements Comparable<Pair> {

		private Document doc;
		private int position;

		public Pair(Document doc, int position) {
			this.doc = doc;
			this.position = position;
		}

		public Document getDocument() {
			return this.doc;
		}

		public int getPosition() {
			return this.position;
		}

		@Override
		public int compareTo(Pair o) {
			int comp = this.getDocument().getId().compareTo(o.getDocument().getId());
			if (comp != 0) {
				return comp;
			} else {
				return this.getPosition() > o.getPosition() ? +1 : this.getPosition() < o.getPosition() ? -1 : 0;
			}
		}

		@Override
		public String toString() {
			return "(" + this.getDocument().getId() + ", " + this.getPosition() + ")";
		}

	}

	public PhraseSearchIndex(Corpus corpus) {
		super(corpus);
	}

	@Override
	public Map<Document, List<Integer>> searchPhrase(String phrase) {

		String[] terms = phrase.trim().split("\\s+");

		return this.searchPhrase(Arrays.asList(terms));

	}

	@Override
	public List<String> getContext(String phrase, Document doc, int pos) {
		// TODO Auto-generated method stub
		return null;
	}

}
